<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>匿名函数和闭包(上)</title>
    <script type="text/javascript" src="demo.js"></script>
</head>
<body>

</body>
</html>
<!--
匿名函数就是没有名字的函数，闭包是可访问一个函数作用域变量里的函数。声明：本节内容需要有面向对象和少量设计模式基础，
否则无法听懂。
一、匿名函数
//普通函数
function box() {            //函数名是box
    return 'Lee';
}

//匿名函数
function () {               //匿名函数，会报错
    return 'Lee';
}

//通过表达式自我执行
(function box() {           //封装成表达式
    alert('Lee');
})();                       //()表示执行函数，并且传参

//把匿名函数赋值给变量
var box = function () {     //将匿名函数赋值给变量
    return 'Lee';
};
alert(box());               //调用方式和函数调用相似

//函数里的匿名函数
function box() {
    return function () {    //函数里的匿名函数，产生闭包
        return 'Lee';
    };
}
alert(box);                 //调用匿名函数

二、闭包
闭包是指有权访问另一个函数作用域中的变量的函数，创建闭包的常见的方式，就是在一个函数内部创建另一个函数，通过另一个函数
访问这个函数的局部变量。
//通过闭包可以返回局部变量
function box() {
    var user = 'Lee';
    return function () {    //通过匿名函数返回box()局部变量
        return user;
    };
}
alert(box()());             //通过box()()来直接调用匿名函数返回值

var b = box();
alert(b());                 //另一种调用匿名函数返回值

使用闭包有一个优点，也是它的缺点：就是可以把局部变量驻留在内存中，可以避免使用全局变量。(全局变量污染导致应用程序不可预测性，每个
模块都可调用必将引来灾难，所以推荐使用私有的，封装的局部变量)。

//通过全局变量来累加
var age = 100;              //全局变量
function box() {
    age++;                  //模块级可以调用全局变量，进行累加
}
box();                      //执行函数，累加了
alert(age);                 //输出全局变量

//通过局部变量无法实现累加
function box () {
    var age = 100;
    age++;
    return age;
}
alert(box());               //101
alert(box());               //101，无法实现，因为又被初始化了

//通过闭包可以实现局部变量的累加
function box () {
    var age = 100;
    return function () {
        age++;
        return age;
    };
}
var b = box();              //获得函数
alert(b());                 //调用匿名函数
alert(b());                 //第二次调用匿名函数，实现累加
PS：由于闭包里作用域返回的局部变量资源不会被立刻销毁回收，所以可能会占用更多的内存。过度使用闭包会导致性能下降，建议在非常有必要
的时候才使用闭包。

作用域链的机制导致一个问题，在循环中的匿名函数取得的任何变量都是最后一个值。
//循环里包含匿名函数
function box() {
    var arr = [];
    for (var i = 0; i < 5; i++) {
        arr[i] = function () {
            return i;
        };
    }
    return arr;
}

var b = box();             //得到函数数组
alert(b.length);           //得到函数集合长度
for (var i = 0; i < b.length; i++) {
    alert(b[i]());         //输出每个函数的值，都是最后一个数
}

上面的例子输出的结果都是5，也就是循环后得到的最大的i值。因为b[i]调用的是匿名函数，匿名函数并没有自我执行，等到调用的时候，
box()已执行完毕，i早已变成5，所以最终的结果就是5个5。

//循环里包含匿名函数-改1
function box() {
    var arr = [];
    for (var i = 0; i < 5; i++) {
        arr[i] = (function (num) {  //自我执行
            return num;
        })(i);                      //并且传参
    }
    return arr;
}

var b = box();
for (var i = 0; i < b.length; i++) {
    alert(b[i]);                   //这里返回的是数组，直接打印即可
}

改1中，我们让匿名函数进行自我执行，导致最终返回给a[i]的是数组而不是函数了。最终导致b[0]-b[4]中保留了0,1,2,3,4的值。

//循环里包含匿名函数-改2，匿名函数下再做个匿名函数

-->